{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fmodern\fprq1 Lucida Console;}{\f2\fmodern\fprq1\fcharset0 Lucida Console;}{\f3\fnil\fcharset0 Arial;}{\f4\fnil Calibri;}}
{\colortbl ;\red155\green0\blue211;\red255\green0\blue0;\red0\green0\blue0;\red0\green0\blue255;\red28\green168\blue0;\red177\green72\blue198;\red192\green160\blue0;\red0\green168\blue154;\red212\green44\blue58;\red0\green240\blue240;\red0\green242\blue0;\red128\green0\blue0;}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sa200\sl240\slmult1\b\f0\fs22\lang9 GIT\b0 :GIT is distributed version control system.\par
To create the configuration:\b\par
git config \tab\tab -->\b0 will give list of variables\par
\b git config --global --list  \tab\tab -->\b0 gives the list of existing login credentials\par
\b git config --global user.name "veena"  -->\b0 set the user name.if the same command is given,overwrites the existing credentials\par
\b git config --global user.email "veenanjalitammina999@gmail.com"   -->\b0 to set the email\par
\b git config --global --get user.name\tab ->\b0 give the user name\par
\b git config --global --get user.email       ->\b0 give the email\b\par
git init\tab\tab -->\b0 Transform the current directory into a Git repository. This adds a .git subdirectory to the current directory .By default it creates in master branch.\b\par
git init <directory>   -->\b0 create a new subdirectory called \lang1033 <\lang9 directory\lang1033 >\lang9 containing nothing but the .git subdirectory.\par
\b git init <directory> --template=<template_directory>\tab -->  \b0 --template option allows you to specify a directory to use as a template when initializing a new Git repository.\b\par
git status\tab\tab -->\b0 will give the status of the repository\par
\b git init -b main\tab\tab -->\b0 creates local repository in main branch.(creates a hidden .git folder where staging area and commits will be present there)(b->branch)\par
#To commit the changes, the file should be in staging area,for staging "\b add"\b0  is used\par
\b git add file1.txt\tab\tab -->\b0 will add the file to staging environment but not committed\par
\b git log\tab\tab\tab -->\b0 will show all the commits\par
\b git commit -m "message that specify what features are added"  \par
\cf1\b0 #for each commit, checksum(14 digit hexadecimal value,only first seven digits will be displayed)\b  \b0 will be given\b .\par
\cf0\b0 #Everytime the changes are made,the file should commit.To commit the file directly by skipping the staging,use -a\par
\b git commit -a -m "file moves from working directory to commit without moving to staging \b0 area"                                   # \b -\b0 a option doesn't require a separate git add step before committing\b .\b0\par
\b git diff   #\b0 give the changes that are made before adding the file to staging area.If the file is added using 'add' then diff won't show wany changes.\par
\b git diff -staged     \b0 #give the changes that are made in staging area\par
\b git add .      \b0\tab   #add all the files to the staging area\par
\b git rm --cached file.txt    \b0 #remove the file from git\par
\b git commit -m "removed the file"\par
git rev-list --count HEAD   #\b0 to get the count of commits\par
\b git rev-list --count <branch-name>  #\b0 for each branch\par
\b\par
git branch -M main      \b0 #creating a main branch\par
#settingup ssh\par
\b ssh-keygen -o  #\b0 generates the key and asks the filename to save the key.default stores in id_rsa.pub(stores public key),id_rsa(stores privaqte key) files in .ssh folder.\par
\b git remote add origin sshurlofrepo  #\b0 here instead of ssh url https url can also be given,but for https url it asks for the authentication.It is used to add a remote repository to a local Git repository. In this case, origin is typically used as the name of the remote, and sshurlofrepo is the SSH URL of the remote Git repository.\b\par
git push -u origin main\tab             \b0 #push the repository from local machine to remote repository\par
\cf1 #\b after pushing into remote repository,if any changes made to local macine repository,then the repository need to push again to remote repository to commit .'-u' option maintains the link between local and remote repositories.\cf2\par
\cf3 git remote -v\tab\tab\tab #\cf2 checking existing remotes\cf3\par
git remote remove origin\tab #\b0 remove the origin remote\cf0\par
\b git tag v1.0 -m "release1"\tab #\b0 adds the tag to local repository\par
\b git tag   \tab\tab\tab\tab\b0 #shows  the list of tags\par
\b git push origin v1.0\tab\tab #\b0 adds the tag to remote repository\par
\b git show v1.0 \tab\tab\tab #\b0 shows info about version v1.0\par
\b git log --pretty=oneline\tab #\b0 give the short logs of commits\par
\b git switch -c feature1\tab\tab #creating new branch named feature1,no limit in creating branches.\par
git switch main\tab\tab\tab #switch to main branch\par
git branch \tab\tab\tab #\b0 gives the list of branches and highlight the active branch\par
\b git branch -all\b0\tab\tab\tab #gives the list of branches in local machine along with remote repository\par
\b git switch - \tab\tab\tab #\b0 changes to previous branch\par
#assume that you are in the main branch,and repoitory has feature branch,now to merge feature branch into main ,you should be in main branch and execute the following command.Before pushing, pull the main branch from main repository and do merging.After merging push it back to the remote repository\par
\b git merge feature\tab #\b0 merging feature branch in main\b\tab\par
git show:file1.txt\tab\tab #\b0 shows the contents of previous version\b\par
git show <commit_hash>:file1.txt\tab #\b0 shows the content of specified commit hash\par
\b git clone <repo url>\tab\tab\tab #\b0 create a copy of remote repositories\b\par
\b0\par
\cf2\b\fs28 counting commits:\par
\cf0\b0\fs22 to count all commits in the current branch (assuming you are on the master branch),\par
\b git rev-list --count HEAD                   #\b0 to count all the commits in the current branch\par
\b git rev-list --count HEAD -- <file_path>   #\b0 Count commits for a specific file:\par
\b git rev-list --count <branch_name>   #\b0 Count commits for a specific branch:\par
\cf2\b\fs32 git config levels\tab :\par
\cf1\fs24  --local(Repository/Project level)\par
\cf0\b0\fs22 By default, git config will write to a local level if no configuration option is passed.Local configuration values are stored in a file that can be found in the repo's .git directory: .git/config \b\tab\b0\par
\cf1\b\fs24 --global(User level)\par
\cf0\b0\fs22 Global level configuration is user-specific, meaning it is applied to an operating system user. Global configuration values are stored in a file that is located in a user's home directory. ~ /.gitconfig on unix systems and C:\\Users{{\field{\*\fldinst{HYPERLINK "\\\\\\\\.gitconfig"}}{\fldrslt{\\\\.gitconfig\ul0\cf0}}}}\f0\fs22  on windows \b\par
\cf1\fs24\par
 --system(Git installation)\par
\cf0\b0\fs22 System-level configuration is applied across an entire machine. This covers all users on an operating system and all repos. The system level configuration file lives in a gitconfig file off the system root path. \par
\b git config --list --show-origin     #\b0 check complete git config\par
\b git config --global --unset user.name   #\b0 removes the user name only\b\par
git config --local --remove-section user  #\b0 removes the complete section\par
\par
\cf2\b How git stores the data?\par
\cf0\b0 Git stores data as objects . There are three main types of objects in Git: blobs, trees, and commit\par
A \b blob\b0  represents the content of a file at a specific state. Blobs store the actual file data, and they are uniquely identified by a SHA-1 hash of their contents.\par
A \b tree object \b0 represents a directory and its contents. It points to blobs (file contents) and other tree objects (subdirectories). The tree object is also identified by a SHA-1 hash\par
A \b commit object \b0 represents a snapshot of the entire project at a specific point in time.Commits are also identified by a SHA-1 hash.(SHA-1 is 20 bytes in hexadecimal format)\par
To decode the hash,use\par
\b git cat-file sha-1 -p\par
\par
\cf1 Renaming file in git:\par
\cf0 git mv file1.txt file.txt  #\b0 renames file1.txt to file.txt\par
\cf2\b\fs28 git restore\cf0\b0\fs22\par
\cf1\b Removing the files in staging area:\par
\cf0 git restore --staged file.txt  #\b0 moves the file from staging area to unstaged area\par
This command restores the specified file from the last commit to the staging area. It undoes changes that were previously added to the staging area but not committed.\par
\b git restore  --worktree file.txt\par
\b0 This command restores the specified file from the last commit to your working directory. It discards changes in both the staging area and the working directory.\par
\b git restore file.txt    #to discard \b0 the changes that are made in unstaging area\par
\b git restore --source=<commit> <file>  #\b0 restore the file to  state it was in the given commit \par
\par
\cf2\b\fs28 git checkout\par
\cf0\b0\fs22 To switch to an existing branch:\par
\b git checkout <branch_name>\par
\b0 To create and switch to a new branch:\par
\b git checkout -b <new_branch>\par
\b0 To discard changes in a specific file:\par
\b git checkout -- <file>\par
\b0 To discard all changes in the working directory (use with caution, as it's not reversible). used to discard changes in tracked files, and it won't remove untracked files in your working directory.\par
\cf1\b git clean -fdX\cf0\par
\b0 To remove untracked files, you can use the git clean command. The -d option tells Git to also remove untracked directories, and the -X option ensures that only untracked files are removed, not untracked directories\par
\cf1\b git clean -fdXn\par
\cf0\b0 This will show you a preview of the files that would be deleted without actually deleting them.\par
\b git checkout -- .\par
\b0 Checking Out a Specific Commit (Detached HEAD state):\par
To view a specific commit without creating a branch:\par
\b git checkout <commit_hash>\par
\b0 Checking Out a Specific File from a Different Commit:\par
To replace a file in the working directory with the version from a different commit\par
\b git checkout <commit_hash> -- <file>\par
\b0 Switching Back to the Previous Branch:\par
If you switch to a commit directly and want to return to the previous branch:\par
git checkout -\par
Switching to a Tag:\par
To switch to a specific tag:\par
\b git checkout tags/<tag_name>\b0\par
\cf2\b\par
\fs28 Creating a branch:\par
\cf1\fs22 creating a branch and switch to new branch in one command\cf0\par
git checkout -b <branchname>\par
git switch -c <branch_name>\par
\b0 These two command creates a new branch (<branch_name>) and switches your working directory to that branch. If the branch already exists, it will switch to that branch. If it doesn't exist, Git will create it for you.\par
\cf1\b creating a branch\par
\cf0 git branch <branch_name>\par
\b0 This command creates a new branch named <branch_name> but doesn't switch to it. \par
\cf1\b Using git clone with git checkout -b (from a remote repository):\par
\cf0 git clone <repository_url> -b <branch_name>\par
\b0 If you are cloning a repository and want to create and switch to a new branch right away\par
\cf1\b creating a branch upto a specific commit hash\par
\cf0 git checkout -b <branch_name> <commit_hash>\par
\b0 this command create a  new branch upto the specified commit hash\cf1\b\par
 create a new local branch that tracks a remote branch.\par
\cf0 git branch --track <local_branch_name> origin/<remote_branch_name>\par
\b0 creates a new local branch that tracks a remote branch\par
\cf1\b creating a branch which doesn't have any commit history\par
\cf0 git checkout --orphan <branch_name>\par
\b0 This creates a new branch named <branch_name> without any commit history.But it will have contents\par
\b git rm --cached <file>\par
\b0  used to remove a file from the Git index (staging area) without removing it from the working directory \par
\b git rm -f <file>\par
\b0 This command forcibly removes the specified file from the Git index and the working directory, even if it has been modified.\b\par
git rm -rf .\par
\b0 This command removes only tracked files and directories from the working directory.\par
\b git commit --allow-empty -m "Initial commit"\par
\b0 The --allow-empty option in Git is used when you want to create a commit even if there are no changes to the files in the working directory.\b\par
\cf2\par
Renaming a branch:\par
\cf0\b0 Move to the branch that to you want to rename through git checkout command\par
git checkout branch1   \par
git branch -m new_branch   #renames to new_branch\par
\cf2\b Deleting a branch\par
\cf0 git branch -d delete_branch  \b0 #will generate warning if you commit changes to the branch\par
\b git branch -D delete_branch\tab #\b0 will delete the branch forcefully\cf2\b\par
\par
HEAD pointer:\par
\cf0\b0 HEAD points to the latest commit on the currently active branch.\par
When you switch branches in Git, the HEAD pointer moves to point to the latest commit of the branch you just switched to. If you were on branch1 and made a commit, and then you switched to the main branch, HEAD will now point to the latest commit on the main branch.\cf2\b\par
\fs28 configuring editor for git\cf0 :\par
\fs22 git config --global core.editor <editor-name>\par
\b0 git config --global core.editor vim  #setting vim as editor\par
\b git config --get core.editor\b0\tab\tab #to get the current configured editor\par
\b git config --global --unset core.editor   #\b0 unset the currently configured editor\par
\par
\b\par
\cf2\fs28 Merging up branches\cf0 :\par
\b0\fs22 In Git, there are two common types of merges: fast-forward merges and recursive merges.\par
Fast-Forward Merges:\b\fs28\par
\fs22 git merge <source-branch>\tab\tab #\b0 to execute this you should be in the taget branch\par
If there are no conflicts, Git will automatically perform the merge. If there are conflicts, Git will mark the conflicted files, and you'll need to resolve the conflicts manually.\par
\b git merge --abort\tab\tab\tab #\b0 aborts the merge process\b\par
\b0 When you perform a merge in Git, the branch being merged is typically not automatically deleted. Git does not automatically delete branches after a merge\par
# Delete the merged branch locally\b\par
git branch -d <branch-name>\b0\par
If you have already pushed the merged branch to a remote repository and you want to delete it there:\par
 # Delete the merged branch on the remote repository\par
\b git push origin --delete <branch-name>\par
\par
\cf2 #FAST FORWARD MERGING\cf0 -Here HEAD pointer will move to the latest commit.no new commit will be created.\par
\cf5\b0\f1 vlab@VEDA-2F101 \cf6 MINGW64 \cf7 ~/Desktop/git_project\cf8  (master)\par
\cf0 $ git branch\par
* \cf5 master\par
\par
vlab@VEDA-2F101 \cf6 MINGW64 \cf7 ~/Desktop/git_project\cf8  (master)\par
\cf0 $ git switch -c branch1\par
Switched to a new branch 'branch1'\par
\par
\cf5 vlab@VEDA-2F101 \cf6 MINGW64 \cf7 ~/Desktop/git_project\cf8  (branch1)\par
\cf0 $ ls\par
file1.txt  file2.txt  file3.txt\par
\par
\cf5 vlab@VEDA-2F101 \cf6 MINGW64 \cf7 ~/Desktop/git_project\cf8  (branch1)\par
\cf0 $ vi file4.txt\par
\par
\cf5 vlab@VEDA-2F101 \cf6 MINGW64 \cf7 ~/Desktop/git_project\cf8  (branch1)\par
\cf0 $ git add .\par
warning: in the working copy of 'file4.txt', LF will be replaced by CRLF the next time Git touches it\par
\par
\cf5 vlab@VEDA-2F101 \cf6 MINGW64 \cf7 ~/Desktop/git_project\cf8  (branch1)\par
\cf0 $ git commit -m "commit done"\par
[branch1 3fba440] commit done\par
 1 file changed, 1 insertion(+)\par
 create mode 100644 file4.txt\par
\par
\cf5 vlab@VEDA-2F101 \cf6 MINGW64 \cf7 ~/Desktop/git_project\cf8  (branch1)\par
\cf0 $ git status\par
On branch branch1\par
nothing to commit, working tree clean\par
\par
\cf5 vlab@VEDA-2F101 \cf6 MINGW64 \cf7 ~/Desktop/git_project\cf8  (branch1)\par
\cf0 $ git switch master\par
Switched to branch 'master'\par
\par
\cf5 vlab@VEDA-2F101 \cf6 MINGW64 \cf7 ~/Desktop/git_project\cf8  (master)\par
\cf0 $ git merge branch1\par
Updating b1f8b4d..3fba440\par
Fast-forward\par
 file4.txt | 1 \cf5 +\par
\cf0  1 file changed, 1 insertion(+)\par
 create mode 100644 file4.txt\par
\par
\cf2\b\f2\lang1033 Recursive merge-\cf0\b0 new commit will be created after merging 2 branches.\cf2\b\f1\lang9\par
\cf0\b0\par
\cf5 vlab@VEDA-2F101 \cf6 MINGW64 \cf7 ~/Desktop/git_project\cf8  (master)\par
\cf0 $ git branch\par
  branch1\par
* \cf5 master\par
\par
vlab@VEDA-2F101 \cf6 MINGW64 \cf7 ~/Desktop/git_project\cf8  (master)\par
\cf0 $ vi file7.txt\par
\par
\cf5 vlab@VEDA-2F101 \cf6 MINGW64 \cf7 ~/Desktop/git_project\cf8  (master)\par
\cf0 $ git add .\par
\par
\cf5 vlab@VEDA-2F101 \cf6 MINGW64 \cf7 ~/Desktop/git_project\cf8  (master)\par
\cf0 $ git commit -m "commit1"\par
[master 9ee9db8] commit1\par
 1 file changed, 0 insertions(+), 0 deletions(-)\par
 create mode 100644 file7.txt\par
\par
\cf5 vlab@VEDA-2F101 \cf6 MINGW64 \cf7 ~/Desktop/git_project\cf8  (master)\par
\cf0 $ git switch branch1\par
Switched to branch 'branch1'\par
\par
\cf5 vlab@VEDA-2F101 \cf6 MINGW64 \cf7 ~/Desktop/git_project\cf8  (branch1)\par
\cf0 $ vi file11.txt\par
\par
\cf5 vlab@VEDA-2F101 \cf6 MINGW64 \cf7 ~/Desktop/git_project\cf8  (branch1)\par
\cf0 $ git status\par
On branch branch1\par
Untracked files:\par
  (use "git add <file>..." to include in what will be committed)\par
        \cf9 file11.txt\par
\par
\cf0 nothing added to commit but untracked files present (use "git add" to track)\par
\par
\cf5 vlab@VEDA-2F101 \cf6 MINGW64 \cf7 ~/Desktop/git_project\cf8  (branch1)\par
\cf0 $ git add file11.txt\par
\par
\cf5 vlab@VEDA-2F101 \cf6 MINGW64 \cf7 ~/Desktop/git_project\cf8  (branch1)\par
\cf0 $ git commit -m "commit2"\par
[branch1 97a4420] commit2\par
 1 file changed, 0 insertions(+), 0 deletions(-)\par
 create mode 100644 file11.txt\par
\par
\cf5 vlab@VEDA-2F101 \cf6 MINGW64 \cf7 ~/Desktop/git_project\cf8  (branch1)\par
\cf0 $ git status\par
On branch branch1\par
nothing to commit, working tree clean\par
\par
\cf5 vlab@VEDA-2F101 \cf6 MINGW64 \cf7 ~/Desktop/git_project\cf8  (branch1)\par
\cf0 $ git switch master\par
Switched to branch 'master'\par
\par
\cf5 vlab@VEDA-2F101 \cf6 MINGW64 \cf7 ~/Desktop/git_project\cf8  (master)\par
\cf0 $ git merge branch1\par
hint: Waiting for your editor to close the file... unix2dos: converting file C:/Users/VLAB/Desktop/git_project/.git/MERGE_MSG to DOS format...\par
dos2unix: converting file C:/Users/VLAB/Desktop/git_project/.git/MERGE_MSG to Unix format...\par
Merge made by the 'ort' strategy.\par
 file11.txt | 0\par
 1 file changed, 0 insertions(+), 0 deletions(-)\par
 create mode 100644 file11.txt\par
\par
\cf5 vlab@VEDA-2F101 \cf6 MINGW64 \cf7 ~/Desktop/git_project\cf8  (master)\par
\cf0 $ git status\par
On branch master\par
nothing to commit, working tree clean\par
\par
\cf5 vlab@VEDA-2F101 \cf6 MINGW64 \cf7 ~/Desktop/git_project\cf8  (master)\par
\cf0 $ git log\par
\cf7 commit ce90a783063e2ec6c20e3578f9b05d6564e36923 (\cf10 HEAD\cf7  -> \cf11 master\cf7 )\par
\cf0 Merge: 9ee9db8 97a4420\par
Author: veena <veenanjalitammina999@gmail.com>\par
Date:   Fri Mar 1 15:07:25 2024 +0530\par
\par
    recursive merge\par
\par
\cf7 commit 97a4420bdb3206a8a726f2e22218c2d075840824 (\cf11 branch1\cf7 )\par
\cf0 Author: veena <veenanjalitammina999@gmail.com>\par
Date:   Fri Mar 1 15:06:20 2024 +0530\par
\par
    commit2\par
\par
\cf7 commit 9ee9db8f718f2ff60bfa2b3266d9ba8d4adb09bc\par
\cf0 Author: veena <veenanjalitammina999@gmail.com>\par
Date:   Fri Mar 1 15:00:20 2024 +0530\par
\par
    commit1\par
\par
\cf7 commit 533e29b1e630540765623b8d0b016742913a5438\par
\cf0 Author: veena <veenanjalitammina999@gmail.com>\par
Date:   Fri Mar 1 14:58:23 2024 +0530\par
\par
    file 6 added\par
\par
\cf7 commit b21f8c7ecfff63826ad09d514b0ddb7392c7a3f9\par
\cf0 Author: veena <veenanjalitammina999@gmail.com>\par
Date:   Fri Mar 1 14:54:04 2024 +0530\par
\par
    file5 added\par
\par
\cf7 commit 3fba440059fa5595936136dbf7d49d78332f8ebb\par
\cf0 Author: veena <veenanjalitammina999@gmail.com>\par
Date:   Fri Mar 1 14:48:25 2024 +0530\par
\par
    commit done\par
\par
\cf7 commit b1f8b4d99f62c7e09c330f96047713b26c171f08\par
\cf0 Author: veena <veenanjalitammina999@gmail.com>\par
Date:   Fri Mar 1 12:03:08 2024 +0530\par
\par
\b\f0\par
\par
\cf2\fs28 Colored outputs\par
\cf0\b0\fs22 git config command is used to set these color values.\par
\b color.ui\tab\tab -->\b0 mastervariable to set git colors.setting it to false  disable all Git's colored terminal output.\par
By default, color.ui is set to auto which will apply colors to the immediate terminal output stream. The auto setting will omit color code output if the output stream is redirected to a file or piped to another process.\par
You can set the color.ui value to always which will also apply color code output when redirecting the output stream to files or pipes\par
\par
\b git reset HEAD --\par
\b0 This command unstages all changes that have been added to the index (staging area). The double hyphen (--) is used to indicate the end of options and is typically not necessary in this context, but it's a good practice to include it to avoid ambiguity.\par
\par
\par
\cf2\b\fs32 git cherrypick:\par
\cf0\b0\fs22 This will open the editor without modifying the commit message.\par
Cherrypick is used for the bug fixes where you want to place that bugfix commit in all the version branches.\par
Also used when we accidentally made a commit in wrong branch\par
\par
\cf2\b\fs28 git reset:\par
\cf0\b0\fs22 used to move the files from staging area to working directory\par
moves the head to specific commit\par
git reset \cf7 57c6fe3\lang1033  \tab\cf0 #MOVES THE HEAD TO SPECIFIED COMMIT WHATEVER THE CHANGES AFTER THE COMMIT WILL MOVE TO THE WORKING area\cf7\lang9\par
\cf0 git reset \cf7 57c6fe3\lang1033  --hard     \cf0 #moves the head  to specified commit and whatever the changes after specificed commit will not even seen in working area\par
\lang9 git reset \cf7 57c6fe3\lang1033  --soft     \cf0 #moves the head  to specified commit and whatever the changes after specificed commit will move to staging area\par
git reset HEAD --mixed   #moves the stages changes to unstaging area  --mixed is defaullt option\par
git reset   ====   git reset --mixed HEAD\par
git reset --soft HEAD^\par
\par
\cf2\b\fs28 git stash:\par
\cf0\fs22 if \b0 you switch branch without commiting then:\par
-> switches to the branch carrying changes\par
-> git won't allow to switch without commit or stash the changes\par
\par
\b git stash\b0\par
\b git stash show\par
\b0 display the changes made in the most recent stash\par
\b git stash show -v\par
git stash show -p\par
git stash show stash@\{2\}   #\b0 Show Changes for a Specific Stash\par
\b git stash list\par
git stash pop  #\b0 recentstash will be applied and removed from stash list\b\par
git stash save "stash name"\par
git stash drop stash@\{1\}\b0\par
\lang9\par
\par
\cf2\b\fs28 Creating alias  \par
\cf0\b0\fs22 Aliases can be created through two primary methods:\par
\b 1\cf1 )Directly editing Git config files\cf0\b0 :The global or local config files can be manually edited and saved to create aliases. The global config file lives at $HOME/.gitconfig file path. The local path lives within an active git repository at /.git/config\par
\b 2\cf1 )Using the git config to create aliases\cf2\fs28\par
\cf0\fs22 git config --global alias.<alias-name> '<git-command>'\tab\tab\par
Ex:git config --global alias.co checkout\tab\tab #\b0 alias created for checkout command\cf2\b\fs28\par
\cf0\fs22 git config --global alias.unstage 'reset HEAD --'\tab\tab #\b0 alias createdfor unstaging\b\par
\b0\par
\par
\cf2\b\fs28 git checkout\par
\cf0\b0\fs22 If you have modifications in your working directory that are not yet staged (unstaged changes) and you want to discard them, you can use the git checkout command to revert the changes. \par
git checkout to remove changes from a modified file in your working directory. However, git checkout is generally used to switch branches, and using it to remove changes requires a specific syntax\b .\par
git checkout -- file.txt\par
\b0 Replace file.txt with the name of the file for which you want to discard the unstaged changes.\par
#To remove all unstaged changes in your working directory (for all files), you can use:\par
\b git checkout -- .\par
\b0 The . indicates the current directory, and this command will revert all unstaged changes.\par
\par
\cf12\b\fs24 # Unstaged changes\par
git reset HEAD -- file.txt\par
\par
# Discard unstaged changes in working directory\par
git checkout -- file.txt\par
\cf0\fs22\par
git add .\tab\tab #\b0 add all the files in current dirctory to the staging area \par
\par
\cf2\b\fs28 git commit -ammend\cf0\b0\fs22\par
The git commit --amend command is used to modify the most recent commit in Git. When you run this command, it allows you to make changes to the previous commit message.\par
\b git commit --amend\par
\b0 This opens your default text editor (such as Vim, Nano, or Notepad) with the commit message of the last commit.\par
\b git commit --amend --no-edit\par
\b0 This will open the editor without modifying the commit message.\par
\cf2\b\fs28 git diff\par
\cf0\b0\fs22 The git diff HEAD ./path/to/file command is used to view the changes made to a specific file in the working directory compared to the most recent commit (HEAD)\par
git diff: Initiates the diff command in Git.\par
HEAD: Refers to the most recent commit on the current branch. It's the commit that HEAD is currently pointing to.\par
./path/to/file: Specifies the path to the specific file you want to examine.\par
\par

\pard\sa200\sl240\slmult1\tx3510\cf2\b\fs28 git diff --staged   ==  git diff --cached\cf0\b0\fs22\par
This command is an alternative way of expressing the same concept as git diff --cached.            It also shows the changes that are staged but not yet committed.\par
\cf1\b\fs24 git diff without a file path will compare changes across the entire repository\cf0\b0\fs22 .\cf1\b\fs24 By default git diff will show you any uncommitted changes since the last commit.\par
\cf0 #Comparing 2 branches\cf1\par
\cf0\fs22 git diff branch1 branch2\par
\par
\cf2\f3\fs28 git stash\cf0\f0\fs22 :\par
\b0 The git stash command takes your uncommitted changes (both staged and unstaged), saves them away for later use, and then reverts them from your working copy. For example:\b\par
git stash apply\par
\b0 If conflicts occur, Git will mark the conflicted areas in the affected files.Resolving conflicts involves manually editing the files to merge the changes. Here's a step-by-step guide on how to resolve conflicts after applying a stash:\par
\b git add <conflicted_file>    \b0 #add the conflicted file\b\par
git stash drop                          \b0 #complete the process by removing the stash\par
 If you created a new file after stashing changes and then dropped the stash, the changes from the stash will not be applied, but the new file you created will remain in your working directory.\par
\b git stash apply\par

\pard\sa200\sl240\slmult1 touch new_file.txt\par
git stash drop\par
\b0 After these steps, the changes from the stash, including modifications to existing files, will not be reapplied to your working directory. However, the new file (new_file.txt) that you created after stashing will remain in your working directory.\par
\par
\b what is ssh key?\par
\b0 In Git, SSH (Secure Shell) is a widely used protocol for securely connecting and authenticating between a Git client (such as your local machine) and a Git server (usually a remote repository host). \par
\b Generate SSH Key Pair\b0 : First, you need to generate an SSH key pair on your local machine. each ssh key includes a public key and a private key. The private key should be kept secure on your machine, and the public key is added to the Git server for authentication.\par
\tab\tab\b ssh-keygen -t rsa -b 4096 -C "your_email@example.com"\par
\b0 ssh-keygen: This is the command-line utility for generating SSH key pairs.\par
-t rsa: Specifies the type of key to create. In this case, it's RSA (Rivest\f4\endash Shamir\endash Adleman), which is a widely used asymmetric encryption algorithm.\par
-b 4096: Specifies the number of bits in the key. A higher number of bits generally increases the security of the key. In this example, a 4096-bit key is generated.\par
-C "your_email@example.com": This option adds a comment or label to the key. The comment is often used to identify the key, and it's typically set to the user's email address. While the comment is optional, adding it can help you identify the key later.\par
\b Add Public Key to Git Server:\par
\b0\f0 Copy the content of your public key (usually ~/.ssh/id_rsa.pub) and add it to your Git server's SSH keys\par
\par
\cf2\b\fs24 Pushing changes to remote repository:\par
\cf0\fs22 git push <remote> <branch>\b0\par
<remote> is the name of the remote repository.\par
<branch> is the branch you want to push.\par
 \cf1\b to push changes to a specific branch in a remote repository\par
\cf0 git push <remote> <local-branch>:<remote-branch>\b0\par
<remote> is the name of the remote repository.\par
<local-branch> is the name of the local branch you want to push.\par
<remote-branch> is the name of the branch on the remote repository where you want to push the changes.\par
\cf1\b to push your local branch to the remote repository, specifying a new branch name on the remote repository.\par
\cf0 git push origin <local-branch>:refs/heads/<new-remote-branch>\par
\b0 refs: This stands for references. In Git, references are pointers or labels associated with a specific commit.\par
heads: This indicates that the references are pointing to the latest commit on branches.\par
\par
To see the list of branches in remote repository\par
\b git ls-remote --heads <remote-name>\par
\par
\cf1 when a repository is cloned from git,only the default branch(main) will be cloned to local machine.\par
\cf0\b0 to see the branches in remote repository,use\par
\cf1\b git branch -r\par
\cf0\b0 to add other branches from remote repo to local machine repo,\cf1\b\par
git switch branch1\par
\cf0\b0 now branch1 from remote repo will be added to the local machine repo.git checks whether there is a branch named branch1 in local repo,if it is not present,it checks in the remote repo.If the branch1 is present in remote repo,it creates a new branch named branch1 in local repo and then sets up track with the branch1 in remote repo\cf1\b\par
\cf2\fs24 git fetch\cf1\fs22 :\cf0\b0 fetches latest info from github ,but don't add it into working directory\par
git fetch <remote>\tab\tab #fetch changes from specified remote repository\par
git fetch <remote><branch>\tab #fetch changes from specified branch in remote repository\par
git fetch doesn't automatically modify your working directory; it updates the remote tracking branches in your local repository.\par
to fetch changes and automatically merge them into your current branch, you can use             \b\fs26 git pull\b0\fs22 . The git pull command is essentially a combination of \b git fetch followed by git merge\b0 :\par
\par
\par
\par
\b\par
\b0\par
}
 